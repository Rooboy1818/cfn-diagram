<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <style type="text/css">
      #mynetwork {
        width: 100%;
        height: 100vh;
        /*border: 1px solid lightgray;*/
      }
      .body {
        font-family: Arial, Helvetica, sans-serif;
      }
      #filtersContainer {
        left: 0px;
        top: 0px;
        height: 100vh;
        width: 400px;
        background-color: rgba(80, 197, 251, 0.7);
        border: blue 4px;
        padding: 3px 3px 3px 3px;
        z-index: 2999;
        position: absolute;
        font-family: "Courier New", Courier, monospace;
        overflow: scroll;
        visibility: hidden;
      }
    </style>
    <script
      type="text/javascript"
      src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"
    ></script>

    <script src="./data.js"></script>

    <script type="text/javascript">
      let network;
      const rule = {
        EventPattern: '{"source":["aws.events"]}',
        EventBusName: "default",
        Target: "MyFunction",
        Name: "AllAWSEvents -> MyFunction",
        InputPath: undefined,
        Input: undefined,
        InputTransformer: {
          InputPathsMap: {
            source: "$.source",
            detailType: "$.detail-type",
            time: "$.time",
          },
          InputTemplate:
            '{"source": <source>, "detail-type": <detailType>, "time": <time> }',
        },
      };

      function preTitle(text) {
        const container = document.createElement("pre");
        container.innerText = text; // You may also use innerHTML if your source is trusted.
        container.style = "font-size: 10px";
        return container;
      }

      function getNode(nodes, id) {
        let found = null;
        nodes.forEach(node => {
          if (node.id === id) {
            found = node;
            return true;
          }
        });
        return found;
      }

      function getNodesWidth(nodes) {
        let min, max;
        nodes.forEach(node => {
          const bbox = network.getBoundingBox(node.id);
          min = min ? Math.min(min, bbox.left) : bbox.left;
          max = max ? Math.max(max, bbox.right) : bbox.right;
        });
        return [min, max];
      }

      function draw() {
        // create a network
        var container = document.getElementById("mynetwork");
        nodes.forEach((node => {
          node.title = preTitle(node.title);
        }));
        var data = {
          nodes: nodes,
          edges: edges,
        };
        var options = {
          layout: {
            randomSeed: 2
          },
          nodes: {
            shape: "custom",
            size: 1,
            ctxRenderer: ({ ctx, id, x, y, state: { selected, hover }, style }) => {
              const node = getNode(data.nodes, id);
              const w = 250;
              const h = 45;
              const drawNode = () => {
                const imageSize = 35;

                // Draw rectangle
                ctx.beginPath();
                ctx.roundRect(x - w / 2, y - h / 2, w, h, [5]);
                ctx.strokeStyle = "#2B7CE9";
                ctx.stroke();
                ctx.fillStyle = "#D2E5FF";
                ctx.fill();

                const truncateText = (text, maxWidth) => {
                  const width = ctx.measureText(text).width;
                  const ellipsis = width > maxWidth ? '...' : '';
                  const length = text.length;
                  for (let i = length; i > 0; i--) {
                    const str = text.substr(0, i) + ellipsis;
                    if (ctx.measureText(str).width <= maxWidth) {
                      return str;
                    }
                  }
                  return '';
                };
                
                // Draw text
                ctx.beginPath();
                ctx.font = "18px Arial";
                ctx.fillStyle = "black";
                ctx.textBaseline = "middle";
                ctx.fillText(truncateText(node.label, w - imageSize - 10), x - w / 2 + 5, y);

                // Draw image
                const nodeBBox = network.getBoundingBox(node.id);
                const nodeImage = new Image();
                nodeImage.src = node.image;
                ctx.drawImage(nodeImage, x + w / 2 - imageSize - 5, y - imageSize / 2, imageSize, imageSize);
              };
              return {
                drawNode,
                nodeDimensions: { width: w, height: h },
              };
            }
          },
          physics: {
            forceAtlas2Based: {
              gravitationalConstant: -26,
              centralGravity: 0.005,
              springLength: 230,
              springConstant: 0.18,
            },
            maxVelocity: 146,
            solver: "forceAtlas2Based",
            timestep: 0.35,
            stabilization: { iterations: 250 }
          },
        };
        network = new vis.Network(container, data, options);
        
        /*network.on("afterDrawing", function (ctx) {
          data.nodes.forEach((node, i) => {
            var nodeBBox = network.getBoundingBox(node.id);
            var nodeImage = new Image();
            nodeImage.src = node.image;
            var imageSize = 45;
            ctx.drawImage(nodeImage, nodeBBox.right - imageSize - 15, nodeBBox.top + (nodeBBox.bottom - nodeBBox.top - imageSize) / 2, imageSize, imageSize);
          });
        });*/

        network.body.emitter.emit("_dataChanged");

        network.once('stabilizationIterationsDone', function() {
          const container = document.getElementById("mynetwork");
          const bounds = getNodesWidth(data.nodes);
          const dom1 = network.canvasToDOM({ x: bounds[0], y: 0});
          const dom2 = network.canvasToDOM({ x: bounds[1], y: 0});
          const offsetX = container.offsetWidth - Number(dom2.x) - Number(dom1.x);
          console.log('marcel widths', container.offsetWidth, bounds, dom1, dom2, offsetX); 
          
          network.moveTo({
            scale : 1.25
          });
          network.moveTo({
            offset: { x: offsetX / 2, y: 0 },
            scale: 0.55,
            animation: {
              duration: 1000,
              easingFunction: 'linear'
            }
          });
        });
      }

      function populateFilters(containerName, data, checked, func) {
        var container = document.getElementById(containerName);
        if (!data.length) {
          container.style.visibility = "hidden";
        }
        for (const name of data) {
          var checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = name;
          checkbox.checked = checked;
          checkbox.name = containerName;
          checkbox.value = name;
          checkbox.addEventListener("click", func);
          var label = document.createElement("label");
          label.htmlFor = name;
          label.appendChild(document.createTextNode(name));

          var br = document.createElement("br");

          container.appendChild(checkbox);
          container.appendChild(label);
          container.appendChild(br);
        }
      }
    </script>
  </head>

  <body>
    <div id="mynetwork"></div>
    <div id="filtersContainer">
      <div id="resource-types">
        <strong>Include resource types:</strong><br />
      </div>
      <div id="nested-stacks">
        <hr />
        <strong>Include nested stack(s):</strong><br />
      </div>
    </div>
    <script>
      window.onload = function (event) {
        if (showSidebar) {
          document.getElementById("filtersContainer").hidden = false;
        }
        populateFilters("nested-stacks", nested, renderAll, (x) => {
          const ns = nodes.get({ filter: (p) => p.prefix === x.target.value });
          for (const n of ns) {
            nodes.update({ id: n.id, hidden: !x.target.checked });
          }
          network.redraw();
        });
        populateFilters("resource-types", types, true, (x) => {
          const ns = nodes.get({ filter: (p) => p.type === x.target.value });
          for (const n of ns) {
            nodes.update({ id: n.id, hidden: !x.target.checked });
          }
          network.redraw();
        });
        draw();
      };
    </script>
  </body>
</html>
