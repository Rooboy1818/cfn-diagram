<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <style type="text/css">
      #mynetwork {
        width: 100%;
        height: 100vh;
      }
      
      .body {
        font-family: Arial, Helvetica, sans-serif;
      }
      
      #filtersContainer, #searchContainer {
        left: 20px;
        top: 35px;
        background-color: #e6f0ff;
        border: 2px solid darkGray;
        border-radius: 7px;
        padding: 10px;
        z-index: 2999;
        position: absolute;
        overflow: auto;
        visibility: hidden;
        font-family: Arial;
        max-height: 600px;
        max-width: 600px;
      }

      #filtersContainer label, #searchContainer label {
        line-height: 25px;
      }

      #filtersContainer label:hover, #searchContainer label:hover {
        font-weight: bold;
      }
      
      #showFilterTypes, #showSearchNodes {
        position: absolute;
        left: 10px;
        top: 10px;
        z-index: 2999;
        color: blue;
      }

      #searchContainer {
        left: 150px;
      }

      #showSearchNodes {
        left: 140px;
      }

    </style>
    <script
      type="text/javascript"
      src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js">
    </script>

    <script src="./data.js"></script>

    <script type="text/javascript">
      let network;
      let nodesView;
      let filteredTypes = types;
      let filtersOpen = false;
      let searchOpen = false;
      let fitScale;

      const rule = {
        EventPattern: '{"source":["aws.events"]}',
        EventBusName: "default",
        Target: "MyFunction",
        Name: "AllAWSEvents -> MyFunction",
        InputPath: undefined,
        Input: undefined,
        InputTransformer: {
          InputPathsMap: {
            source: "$.source",
            detailType: "$.detail-type",
            time: "$.time",
          },
          InputTemplate:
            '{"source": <source>, "detail-type": <detailType>, "time": <time> }',
        },
      };

      function preTitle(text) {
        const container = document.createElement("pre");
        container.innerText = text; // You may also use innerHTML if your source is trusted.
        container.style = "font-size: 10px";
        return container;
      }

      function getNodesWidth(nodes) {
        const bounds = nodes.get().map((node) => {
          const b = network.getBoundingBox(node.id);
          return [b.left, b.right];
        });
        return [Math.min(...bounds[0]), Math.max(...bounds[1])];
      }

      function getOffsetX(nodes) {
        const container = document.getElementById("mynetwork");
        const bounds = getNodesWidth(nodes);
        return container.offsetWidth - network.canvasToDOM({x: bounds[1] - bounds[0], y: 0}).x;
      }

      function draw() {
        // create a network
        var container = document.getElementById("mynetwork");
        nodes.forEach((node => {
          node.title = preTitle(node.title);
        }));

        nodesView = new vis.DataView(nodes, {
          filter: (node) => filteredTypes.includes(node.type)
        });

        var data = {
          nodes: nodesView,
          edges: edges,
        };
        var options = {
          layout: {
            randomSeed: 2
          },
          nodes: {
            shape: "custom",
            size: 1,
            ctxRenderer: ({ ctx, id, x, y, state: { selected, hover }, style }) => {
              const node = nodes.get(id);
              const isSelected = network.getSelectedNodes().includes(node.id);
              const w = 250;
              const h = 45;
              const drawNode = () => {
                const imageSize = 35;

                // Draw rectangle
                ctx.beginPath();
                ctx.roundRect(x - w / 2, y - h / 2, w, h, [3]);
                ctx.strokeStyle = isSelected ? "#FF206A": "#2B7CE9";
                ctx.lineWidth = isSelected ? 5 : 1;
                ctx.stroke();
                ctx.fillStyle = "#D2E5FF";
                ctx.fill();

                const truncateText = (text, maxWidth) => {
                  const width = ctx.measureText(text).width;
                  const ellipsis = width > maxWidth ? '...' : '';
                  const length = text.length;
                  for (let i = length; i > 0; i--) {
                    const str = text.substr(0, i) + ellipsis;
                    if (ctx.measureText(str).width <= maxWidth) {
                      return str;
                    }
                  }
                  return '';
                };
                
                // Draw text
                ctx.beginPath();
                ctx.font = "18px Arial";
                ctx.fillStyle = "black";
                ctx.textBaseline = "middle";
                ctx.fillText(truncateText(node.label, w - imageSize - 10), x - w / 2 + 5, y);

                // Draw image
                const nodeBBox = network.getBoundingBox(node.id);
                const nodeImage = new Image();
                nodeImage.src = node.image;
                ctx.drawImage(nodeImage, x + w / 2 - imageSize - 5, y - imageSize / 2, imageSize, imageSize);
              };
              return {
                drawNode,
                nodeDimensions: { width: w, height: h },
              };
            }
          },
          physics: {
            forceAtlas2Based: {
              gravitationalConstant: -26,
              centralGravity: 0.005,
              springLength: 230,
              springConstant: 0.18,
              avoidOverlap: 1
            },
            maxVelocity: 146,
            solver: "forceAtlas2Based",
            timestep: 0.35,
            stabilization: { iterations: 150 },
          }
        };

        network = new vis.Network(container, data, options);

        network.body.emitter.emit("_dataChanged");

        network.once('stabilizationIterationsDone', function() {
          // Animate the initial loading
          fitScale = network.getScale();
          network.moveTo({
            scale : 1.25
          });
          fit();

          // Reset the avoid overlap
          network.setOptions({
            physics: {
              forceAtlas2Based: {
                avoidOverlap: 0
              }
            }
          });
        });
      }

      function populateFilters(containerName, data, checked, checkboxes, func) {
        var container = document.getElementById(containerName);
        if (!data.length) {
          container.style.display = "none";
        }
        for (const name of data) {
          var checkbox, label;

          // Create checkbox
          if (checkboxes) {
            checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = name;
            checkbox.checked = checked;
            checkbox.name = containerName;
            checkbox.value = name;
          }

          // Create label
          var label = document.createElement("label");
          label.htmlFor = name;
          label.appendChild(document.createTextNode(name));

          // Create line-break
          var br = document.createElement("br");

          // Add event click handler
          if (checkboxes) {
            checkbox.addEventListener("click", func);
          } else {
            label.addEventListener("click", func);
          }

          //Â Add the image
          var img = document.createElement("img");
          img.src = 'data:image/svg+xml;charset=utf-8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Csvg%20width%3D%2280px%22%20height%3D%2280px%22%20viewBox%3D%220%200%2080%2080%22%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%0A%20%20%20%20%3C!--%20Generator%3A%20Sketch%2064%20(93537)%20-%20https%3A%2F%2Fsketch.com%20--%3E%0A%20%20%20%20%3Ctitle%3EIcon-Architecture%2F64%2FArch_AWS-Identity-and-Access-Management_64%3C%2Ftitle%3E%0A%20%20%20%20%3Cdesc%3ECreated%20with%20Sketch.%3C%2Fdesc%3E%0A%20%20%20%20%3Cdefs%3E%0A%20%20%20%20%20%20%20%20%3ClinearGradient%20x1%3D%220%25%22%20y1%3D%22100%25%22%20x2%3D%22100%25%22%20y2%3D%220%25%22%20id%3D%22linearGradient-1%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cstop%20stop-color%3D%22%23BD0816%22%20offset%3D%220%25%22%3E%3C%2Fstop%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cstop%20stop-color%3D%22%23FF5252%22%20offset%3D%22100%25%22%3E%3C%2Fstop%3E%0A%20%20%20%20%20%20%20%20%3C%2FlinearGradient%3E%0A%20%20%20%20%3C%2Fdefs%3E%0A%20%20%20%20%3Cg%20id%3D%22Icon-Architecture%2F64%2FArch_AWS-Identity-and-Access-Management_64%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%0A%20%20%20%20%20%20%20%20%3Cg%20id%3D%22Icon-Architecture-BG%2F64%2FSecurity-Identity-Compliance%22%20fill%3D%22url(%23linearGradient-1)%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Crect%20id%3D%22Rectangle%22%20x%3D%220%22%20y%3D%220%22%20width%3D%2280%22%20height%3D%2280%22%3E%3C%2Frect%3E%0A%20%20%20%20%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M14%2C59%20L66%2C59%20L66%2C21%20L14%2C21%20L14%2C59%20Z%20M68%2C20%20L68%2C60%20C68%2C60.552%2067.553%2C61%2067%2C61%20L13%2C61%20C12.447%2C61%2012%2C60.552%2012%2C60%20L12%2C20%20C12%2C19.448%2012.447%2C19%2013%2C19%20L67%2C19%20C67.553%2C19%2068%2C19.448%2068%2C20%20L68%2C20%20Z%20M44%2C48%20L59%2C48%20L59%2C46%20L44%2C46%20L44%2C48%20Z%20M57%2C42%20L62%2C42%20L62%2C40%20L57%2C40%20L57%2C42%20Z%20M44%2C42%20L52%2C42%20L52%2C40%20L44%2C40%20L44%2C42%20Z%20M29%2C46%20C29%2C45.449%2028.552%2C45%2028%2C45%20C27.448%2C45%2027%2C45.449%2027%2C46%20C27%2C46.551%2027.448%2C47%2028%2C47%20C28.552%2C47%2029%2C46.551%2029%2C46%20L29%2C46%20Z%20M31%2C46%20C31%2C47.302%2030.161%2C48.401%2029%2C48.816%20L29%2C51%20L27%2C51%20L27%2C48.815%20C25.839%2C48.401%2025%2C47.302%2025%2C46%20C25%2C44.346%2026.346%2C43%2028%2C43%20C29.654%2C43%2031%2C44.346%2031%2C46%20L31%2C46%20Z%20M19%2C53.993%20L36.994%2C54%20L36.996%2C50%20L33%2C50%20L33%2C48%20L36.996%2C48%20L36.998%2C45%20L33%2C45%20L33%2C43%20L36.999%2C43%20L37%2C40.007%20L19.006%2C40%20L19%2C53.993%20Z%20M22%2C38.001%20L34%2C38.006%20L34%2C31%20C34.001%2C28.697%2031.197%2C26.677%2028%2C26.675%20L27.996%2C26.675%20C24.804%2C26.675%2022.004%2C28.696%2022.002%2C31%20L22%2C38.001%20Z%20M17%2C54.992%20L17.006%2C39%20C17.006%2C38.734%2017.111%2C38.48%2017.299%2C38.292%20C17.486%2C38.105%2017.741%2C38%2018.006%2C38%20L20%2C38.001%20L20.002%2C31%20C20.004%2C27.512%2023.59%2C24.675%2027.996%2C24.675%20L28%2C24.675%20C32.412%2C24.677%2036.001%2C27.515%2036%2C31%20L36%2C38.007%20L38%2C38.008%20C38.553%2C38.008%2039%2C38.456%2039%2C39.008%20L38.994%2C55%20C38.994%2C55.266%2038.889%2C55.52%2038.701%2C55.708%20C38.514%2C55.895%2038.259%2C56%2037.994%2C56%20L18%2C55.992%20C17.447%2C55.992%2017%2C55.544%2017%2C54.992%20L17%2C54.992%20Z%20M60%2C36%20L62%2C36%20L62%2C34%20L60%2C34%20L60%2C36%20Z%20M44%2C36%20L55%2C36%20L55%2C34%20L44%2C34%20L44%2C36%20Z%22%20id%3D%22AWS-Identity-and-Access-Management_Icon_64_Squid%22%20fill%3D%22%23FFFFFF%22%3E%3C%2Fpath%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E';
          img.width = "24px";
          img.height = "24px";
          
          // Add elements
          if (checkbox) {
            container.appendChild(checkbox);
          }
          container.appendChild(img);
          container.appendChild(label);
          container.appendChild(br);
        }
      }

      function showFilterTypes() {
        const filtersContainer = document.getElementById("filtersContainer");
        filtersContainer.style.visibility = filtersContainer.style.visibility !== "visible" ? "visible" : "hidden";
        setTimeout(() => {
          filtersOpen = filtersContainer.style.visibility === "visible";
        }, 50);
      }

      function showSearchNodes() {
        const searchContainer = document.getElementById("searchContainer");
        searchContainer.style.visibility = searchContainer.style.visibility !== "visible" ? "visible" : "hidden";
        setTimeout(() => {
          searchOpen = searchContainer.style.visibility === "visible";
        }, 50);
      }
      
      document.onclick = function (e) {
        if (filtersOpen) {
          const showFilterTypes = document.getElementById("showFilterTypes");
          const filtersContainer = document.getElementById("filtersContainer");
          if (showFilterTypes.contains(e.target) || !filtersContainer.contains(e.target)) {
            filtersContainer.style.visibility = "hidden";
            filtersOpen = false;
          }
        }
        if (searchOpen) {
          const showSearchNodes = document.getElementById("showSearchNodes");
          const searchContainer = document.getElementById("searchContainer");
          if (showSearchNodes.contains(e.target) || !searchContainer.contains(e.target)) {
            searchContainer.style.visibility = "hidden";
            searchOpen = false;
          }
        }
      }

      function fit() {
        network.moveTo({
          position: {
            x: 0,
            y: 40
          },
          scale: fitScale,
          animation: {
            duration: 1000,
            easingFunction: 'linear'
          }
        });
      }

    </script>
  </head>

  <body>
    <div id="mynetwork"></div>
    <a id="showFilterTypes" onclick="showFilterTypes()">Filter Types</a>
    <div id="filtersContainer">
      <div id="resource-types">
        <strong>Resource Types</strong><br /><br />
      </div>
      <div id="nested-stacks">
        <hr />
        <strong>Nested Stack(s)</strong><br />
      </div>
    </div>
    <a id="showSearchNodes" onclick="showSearchNodes()">Search Nodes</a>
    <div id="searchContainer">
      <div id="search-nodes">
      </div>
    </div>
    <script>
      window.onload = function (event) {
        populateFilters("nested-stacks", nested, renderAll, true, (x) => {
          const ns = nodes.get({ filter: (p) => p.prefix === x.target.value });
          for (const n of ns) {
            nodes.update({ id: n.id, hidden: !x.target.checked });
          }
          network.redraw();
        });

        populateFilters("resource-types", types, true, true, (x) => {
          const { value, checked } = x.target;
          if (checked) {
            filteredTypes = [...filteredTypes.filter(t => t !== value), value];
          } else {
            filteredTypes = filteredTypes.filter(t => t !== value);
          }
          nodesView.refresh();
        });

        const searchNodes = ['No selection', ...nodes.map((node) => node.label).sort()];
        populateFilters("search-nodes", searchNodes, true, false, (x) => {
          // Release focused node
          network.releaseNode();

          // Select and focus node
          const label = x.target.textContent;
          if (label !== 'No selection') {
            const node = nodes.get({
              filter: function (node) {
                return (node.label === label);
              }
            });
            network.selectNodes([node[0].id]);
            network.focus(node[0].id, {
              scale: 1.25,
              animation: {
                duration: 1000,
                easingFunction: 'linear'
              }
            });
          } else {
            network.unselectAll();
            fit();
          }

          // Close search
          const searchContainer = document.getElementById("searchContainer");
          searchContainer.style.visibility = "hidden";
          searchOpen = false;
        });

        draw();
      };

    </script>
  </body>
</html>
